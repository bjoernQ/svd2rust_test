# ! [doc = "Peripheral access API for TEST microcontrollers (generated using svd2rust v0.23.1 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next] svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.23.1/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"] # ! [deny (const_err)] # ! [deny (dead_code)] # ! [deny (improper_ctypes)] # ! [deny (missing_docs)] # ! [deny (no_mangle_generic_items)] # ! [deny (non_shorthand_field_patterns)] # ! [deny (overflowing_literals)] # ! [deny (path_statements)] # ! [deny (patterns_in_fns_without_body)] # ! [deny (private_in_public)] # ! [deny (unconditional_recursion)] # ! [deny (unused_allocation)] # ! [deny (unused_comparisons)] # ! [deny (unused_parens)] # ! [deny (while_true)] # ! [allow (non_camel_case_types)] # ! [allow (non_snake_case)] # ! [no_std] use core :: ops :: Deref ; use core :: marker :: PhantomData ; # [doc = r"Number available in the NVIC for configuring priority"] pub const NVIC_PRIO_BITS : u8 = 3 ; # [allow (unused_imports)] use generic :: * ; # [doc = r"Common register and bit access and modify traits"] pub mod generic { use core :: marker ; # [doc = " Raw register type"] pub trait RegisterSpec { # [doc = " Raw register type (`u8`, `u16`, `u32`, ...)."] type Ux : Copy ; } # [doc = " Trait implemented by readable registers to enable the `read` method."] # [doc = ""] # [doc = " Registers marked with `Writable` can be also `modify`'ed."] pub trait Readable : RegisterSpec { # [doc = " Result from a call to `read` and argument to `modify`."] type Reader : From < R < Self > > + core :: ops :: Deref < Target = R < Self > > ; } # [doc = " Trait implemented by writeable registers."] # [doc = ""] # [doc = " This enables the  `write`, `write_with_zero` and `reset` methods."] # [doc = ""] # [doc = " Registers marked with `Readable` can be also `modify`'ed."] pub trait Writable : RegisterSpec { # [doc = " Writer type argument to `write`, et al."] type Writer : From < W < Self > > + core :: ops :: DerefMut < Target = W < Self > > ; } # [doc = " Reset value of the register."] # [doc = ""] # [doc = " This value is the initial value for the `write` method. It can also be directly written to the"] # [doc = " register by using the `reset` method."] pub trait Resettable : RegisterSpec { # [doc = " Reset value of the register."] fn reset_value () -> Self :: Ux ; } # [doc = " This structure provides volatile access to registers."] # [repr (transparent)] pub struct Reg < REG : RegisterSpec > { register : vcell :: VolatileCell < REG :: Ux > , _marker : marker :: PhantomData < REG > , } unsafe impl < REG : RegisterSpec > Send for Reg < REG > where REG :: Ux : Send { } impl < REG : RegisterSpec > Reg < REG > { # [doc = " Returns the underlying memory address of register."] # [doc = ""] # [doc = " ```ignore"] # [doc = " let reg_ptr = periph.reg.as_ptr();"] # [doc = " ```"] # [inline (always)] pub fn as_ptr (& self) -> * mut REG :: Ux { self . register . as_ptr () } } impl < REG : Readable > Reg < REG > { # [doc = " Reads the contents of a `Readable` register."] # [doc = ""] # [doc = " You can read the raw contents of a register by using `bits`:"] # [doc = " ```ignore"] # [doc = " let bits = periph.reg.read().bits();"] # [doc = " ```"] # [doc = " or get the content of a particular field of a register:"] # [doc = " ```ignore"] # [doc = " let reader = periph.reg.read();"] # [doc = " let bits = reader.field1().bits();"] # [doc = " let flag = reader.field2().bit_is_set();"] # [doc = " ```"] # [inline (always)] pub fn read (& self) -> REG :: Reader { REG :: Reader :: from (R { bits : self . register . get () , _reg : marker :: PhantomData , }) } } impl < REG : Resettable + Writable > Reg < REG > { # [doc = " Writes the reset value to `Writable` register."] # [doc = ""] # [doc = " Resets the register to its initial state."] # [inline (always)] pub fn reset (& self) { self . register . set (REG :: reset_value ()) } # [doc = " Writes bits to a `Writable` register."] # [doc = ""] # [doc = " You can write raw bits into a register:"] # [doc = " ```ignore"] # [doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"] # [doc = " ```"] # [doc = " or write only the fields you need:"] # [doc = " ```ignore"] # [doc = " periph.reg.write(|w| w"] # [doc = "     .field1().bits(newfield1bits)"] # [doc = "     .field2().set_bit()"] # [doc = "     .field3().variant(VARIANT)"] # [doc = " );"] # [doc = " ```"] # [doc = " In the latter case, other fields will be set to their reset value."] # [inline (always)] pub fn write < F > (& self , f : F) where F : FnOnce (& mut REG :: Writer) -> & mut W < REG > { self . register . set (f (& mut REG :: Writer :: from (W { bits : REG :: reset_value () , _reg : marker :: PhantomData , })) . bits ,) ; } } impl < REG : Writable > Reg < REG > where REG :: Ux : Default , { # [doc = " Writes 0 to a `Writable` register."] # [doc = ""] # [doc = " Similar to `write`, but unused bits will contain 0."] # [inline (always)] pub unsafe fn write_with_zero < F > (& self , f : F) where F : FnOnce (& mut REG :: Writer) -> & mut W < REG > { self . register . set ((* f (& mut REG :: Writer :: from (W { bits : REG :: Ux :: default () , _reg : marker :: PhantomData , }))) . bits ,) ; } } impl < REG : Readable + Writable > Reg < REG > { # [doc = " Modifies the contents of the register by reading and then writing it."] # [doc = ""] # [doc = " E.g. to do a read-modify-write sequence to change parts of a register:"] # [doc = " ```ignore"] # [doc = " periph.reg.modify(|r, w| unsafe { w.bits("] # [doc = "    r.bits() | 3"] # [doc = " ) });"] # [doc = " ```"] # [doc = " or"] # [doc = " ```ignore"] # [doc = " periph.reg.modify(|_, w| w"] # [doc = "     .field1().bits(newfield1bits)"] # [doc = "     .field2().set_bit()"] # [doc = "     .field3().variant(VARIANT)"] # [doc = " );"] # [doc = " ```"] # [doc = " Other fields will have the value they had before the call to `modify`."] # [inline (always)] pub fn modify < F > (& self , f : F) where for < 'w > F : FnOnce (& REG :: Reader , & 'w mut REG :: Writer) -> & 'w mut W < REG > { let bits = self . register . get () ; self . register . set (f (& REG :: Reader :: from (R { bits , _reg : marker :: PhantomData , }) , & mut REG :: Writer :: from (W { bits , _reg : marker :: PhantomData , }) ,) . bits ,) ; } } # [doc = " Register reader."] # [doc = ""] # [doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"] # [doc = " method."] pub struct R < REG : RegisterSpec + ? Sized > { pub (crate) bits : REG :: Ux , _reg : marker :: PhantomData < REG > , } impl < REG : RegisterSpec > R < REG > { # [doc = " Reads raw bits from register."] # [inline (always)] pub fn bits (& self) -> REG :: Ux { self . bits } } impl < REG : RegisterSpec , FI > PartialEq < FI > for R < REG > where REG :: Ux : PartialEq , FI : Copy + Into < REG :: Ux > , { # [inline (always)] fn eq (& self , other : & FI) -> bool { self . bits . eq (& (* other) . into ()) } } # [doc = " Register writer."] # [doc = ""] # [doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."] pub struct W < REG : RegisterSpec + ? Sized > { # [doc = "Writable bits"] pub (crate) bits : REG :: Ux , _reg : marker :: PhantomData < REG > , } impl < REG : RegisterSpec > W < REG > { # [doc = " Writes raw bits to the register."] # [inline (always)] pub unsafe fn bits (& mut self , bits : REG :: Ux) -> & mut Self { self . bits = bits ; self } } # [doc = " Field reader."] # [doc = ""] # [doc = " Result of the `read` methods of fields."] pub struct FieldReader < U > { pub (crate) bits : U , } impl < U > FieldReader < U > where U : Copy , { # [doc = " Creates a new instance of the reader."] # [allow (unused)] # [inline (always)] pub (crate) fn new (bits : U) -> Self { Self { bits , } } # [doc = " Reads raw bits from field."] # [inline (always)] pub fn bits (& self) -> U { self . bits } } impl < U , T > PartialEq < T > for FieldReader < U > where U : PartialEq , T : Copy + Into < U > , { # [inline (always)] fn eq (& self , other : & T) -> bool { self . bits . eq (& (* other) . into ()) } } impl FieldReader < bool > { # [doc = " Value of the field as raw bits."] # [inline (always)] pub fn bit (& self) -> bool { self . bits } # [doc = " Returns `true` if the bit is clear (0)."] # [inline (always)] pub fn bit_is_clear (& self) -> bool { ! self . bit () } # [doc = " Returns `true` if the bit is set (1)."] # [inline (always)] pub fn bit_is_set (& self) -> bool { self . bit () } } } # [cfg (feature = "rt")] extern "C" { fn RMT () ; } # [doc (hidden)] pub union Vector { pub _handler : unsafe extern "C" fn () , _reserved : u32 , } # [cfg (feature = "rt")] # [doc (hidden)] pub static __INTERRUPTS : [Vector ; 48] = [Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _handler : RMT } ,] ; # [doc = r"Enumeration of all the interrupts."] # [derive (Copy , Clone , Debug , PartialEq , Eq)] # [repr (u16)] pub enum Interrupt { # [doc = "47 - RMT"] RMT = 47 , } unsafe impl xtensa_lx :: interrupt :: InterruptNumber for Interrupt { # [inline (always)] fn number (self) -> u16 { self as u16 } } # [doc = r" TryFromInterruptError"] # [derive (Debug , Copy , Clone)] pub struct TryFromInterruptError (()) ; impl Interrupt { # [doc = r" Attempt to convert a given value into an `Interrupt`"] # [inline] pub fn try_from (value : u16) -> Result < Self , TryFromInterruptError > { match value { 47 => Ok (Interrupt :: RMT) , _ => Err (TryFromInterruptError (())) , } } } # [doc = "Remote Control Peripheral"] pub struct RMT { _marker : PhantomData < * const () > } unsafe impl Send for RMT { } impl RMT { # [doc = r"Pointer to the register block"] pub const PTR : * const rmt :: RegisterBlock = 0x3ff5_6000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const rmt :: RegisterBlock { Self :: PTR } } impl Deref for RMT { type Target = rmt :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for RMT { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("RMT") . finish () } } # [doc = "Remote Control Peripheral"] pub mod rmt { # [doc = r"Register block"] # [repr (C)] pub struct RegisterBlock { _reserved0 : [u8 ; 0xac] , # [doc = "0xac - "] pub int_clr : crate :: Reg < int_clr :: INT_CLR_SPEC > , } # [doc = "INT_CLR register accessor: an alias for `Reg<INT_CLR_SPEC>`"] pub type INT_CLR = crate :: Reg < int_clr :: INT_CLR_SPEC > ; # [doc = ""] pub mod int_clr { # [doc = "Register `INT_CLR` writer"] pub struct W (crate :: W < INT_CLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INT_CLR_SPEC > ; # [inline (always)] fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)] fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INT_CLR_SPEC >> for W { # [inline (always)] fn from (writer : crate :: W < INT_CLR_SPEC >) -> Self { W (writer) } } # [doc = "Fields `CH(0-7)_TX_END_INT_CLR` writer - Set this bit to clear the rmt_ch%s_rx_end_int_raw.."] pub struct CH_TX_END_INT_CLR_W < 'a > { w : & 'a mut W , offset : usize , } impl < 'a > CH_TX_END_INT_CLR_W < 'a > { # [doc = r"Sets the field bit"] # [inline (always)] pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"] # [inline (always)] pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"] # [inline (always)] pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (1 << self . offset)) | ((value as u32 & 1) << self . offset) ; self . w } } # [doc = "Fields `CH(0-7)_RX_END_INT_CLR` writer - Set this bit to clear the rmt_ch%s_tx_end_int_raw."] pub struct CH_RX_END_INT_CLR_W < 'a > { w : & 'a mut W , offset : usize , } impl < 'a > CH_RX_END_INT_CLR_W < 'a > { # [doc = r"Sets the field bit"] # [inline (always)] pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"] # [inline (always)] pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"] # [inline (always)] pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (1 << self . offset)) | ((value as u32 & 1) << self . offset) ; self . w } } # [doc = "Fields `CH(0-7)_ERR_INT_CLR` writer - Set this bit to clear the rmt_ch%s_err_int_raw."] pub struct CH_ERR_INT_CLR_W < 'a > { w : & 'a mut W , offset : usize , } impl < 'a > CH_ERR_INT_CLR_W < 'a > { # [doc = r"Sets the field bit"] # [inline (always)] pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"] # [inline (always)] pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"] # [inline (always)] pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (1 << self . offset)) | ((value as u32 & 1) << self . offset) ; self . w } } # [doc = "Fields `CH(0-7)_TX_THR_EVENT_INT_CLR` writer - Set this bit to clear the rmt_ch%s_tx_thr_event_int_raw interrupt."] pub struct CH_TX_THR_EVENT_INT_CLR_W < 'a > { w : & 'a mut W , offset : usize , } impl < 'a > CH_TX_THR_EVENT_INT_CLR_W < 'a > { # [doc = r"Sets the field bit"] # [inline (always)] pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"] # [inline (always)] pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"] # [inline (always)] pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (1 << self . offset)) | ((value as u32 & 1) << self . offset) ; self . w } } impl W { # [doc = "Set this bit to clear the rmt_ch(0-7)_rx_end_int_raw.."] # [inline (always)] pub unsafe fn ch_tx_end_int_clr (& mut self , n : usize) -> CH_TX_END_INT_CLR_W { CH_TX_END_INT_CLR_W { w : self , offset : n * 3 } } # [doc = "Bit 0 - Set this bit to clear the rmt_ch0_rx_end_int_raw.."] # [inline (always)] pub fn ch0_tx_end_int_clr (& mut self) -> CH_TX_END_INT_CLR_W { CH_TX_END_INT_CLR_W { w : self , offset : 0 } } # [doc = "Bit 3 - Set this bit to clear the rmt_ch1_rx_end_int_raw.."] # [inline (always)] pub fn ch1_tx_end_int_clr (& mut self) -> CH_TX_END_INT_CLR_W { CH_TX_END_INT_CLR_W { w : self , offset : 3 } } # [doc = "Bit 6 - Set this bit to clear the rmt_ch2_rx_end_int_raw.."] # [inline (always)] pub fn ch2_tx_end_int_clr (& mut self) -> CH_TX_END_INT_CLR_W { CH_TX_END_INT_CLR_W { w : self , offset : 6 } } # [doc = "Bit 9 - Set this bit to clear the rmt_ch3_rx_end_int_raw.."] # [inline (always)] pub fn ch3_tx_end_int_clr (& mut self) -> CH_TX_END_INT_CLR_W { CH_TX_END_INT_CLR_W { w : self , offset : 9 } } # [doc = "Bit 12 - Set this bit to clear the rmt_ch4_rx_end_int_raw.."] # [inline (always)] pub fn ch4_tx_end_int_clr (& mut self) -> CH_TX_END_INT_CLR_W { CH_TX_END_INT_CLR_W { w : self , offset : 12 } } # [doc = "Bit 15 - Set this bit to clear the rmt_ch5_rx_end_int_raw.."] # [inline (always)] pub fn ch5_tx_end_int_clr (& mut self) -> CH_TX_END_INT_CLR_W { CH_TX_END_INT_CLR_W { w : self , offset : 15 } } # [doc = "Bit 18 - Set this bit to clear the rmt_ch6_rx_end_int_raw.."] # [inline (always)] pub fn ch6_tx_end_int_clr (& mut self) -> CH_TX_END_INT_CLR_W { CH_TX_END_INT_CLR_W { w : self , offset : 18 } } # [doc = "Bit 21 - Set this bit to clear the rmt_ch7_rx_end_int_raw.."] # [inline (always)] pub fn ch7_tx_end_int_clr (& mut self) -> CH_TX_END_INT_CLR_W { CH_TX_END_INT_CLR_W { w : self , offset : 21 } } # [doc = "Set this bit to clear the rmt_ch(0-7)_tx_end_int_raw."] # [inline (always)] pub unsafe fn ch_rx_end_int_clr (& mut self , n : usize) -> CH_RX_END_INT_CLR_W { CH_RX_END_INT_CLR_W { w : self , offset : n * 3 + 1 } } # [doc = "Bit 1 - Set this bit to clear the rmt_ch0_tx_end_int_raw."] # [inline (always)] pub fn ch0_rx_end_int_clr (& mut self) -> CH_RX_END_INT_CLR_W { CH_RX_END_INT_CLR_W { w : self , offset : 1 } } # [doc = "Bit 4 - Set this bit to clear the rmt_ch1_tx_end_int_raw."] # [inline (always)] pub fn ch1_rx_end_int_clr (& mut self) -> CH_RX_END_INT_CLR_W { CH_RX_END_INT_CLR_W { w : self , offset : 4 } } # [doc = "Bit 7 - Set this bit to clear the rmt_ch2_tx_end_int_raw."] # [inline (always)] pub fn ch2_rx_end_int_clr (& mut self) -> CH_RX_END_INT_CLR_W { CH_RX_END_INT_CLR_W { w : self , offset : 7 } } # [doc = "Bit 10 - Set this bit to clear the rmt_ch3_tx_end_int_raw."] # [inline (always)] pub fn ch3_rx_end_int_clr (& mut self) -> CH_RX_END_INT_CLR_W { CH_RX_END_INT_CLR_W { w : self , offset : 10 } } # [doc = "Bit 13 - Set this bit to clear the rmt_ch4_tx_end_int_raw."] # [inline (always)] pub fn ch4_rx_end_int_clr (& mut self) -> CH_RX_END_INT_CLR_W { CH_RX_END_INT_CLR_W { w : self , offset : 13 } } # [doc = "Bit 16 - Set this bit to clear the rmt_ch5_tx_end_int_raw."] # [inline (always)] pub fn ch5_rx_end_int_clr (& mut self) -> CH_RX_END_INT_CLR_W { CH_RX_END_INT_CLR_W { w : self , offset : 16 } } # [doc = "Bit 19 - Set this bit to clear the rmt_ch6_tx_end_int_raw."] # [inline (always)] pub fn ch6_rx_end_int_clr (& mut self) -> CH_RX_END_INT_CLR_W { CH_RX_END_INT_CLR_W { w : self , offset : 19 } } # [doc = "Bit 22 - Set this bit to clear the rmt_ch7_tx_end_int_raw."] # [inline (always)] pub fn ch7_rx_end_int_clr (& mut self) -> CH_RX_END_INT_CLR_W { CH_RX_END_INT_CLR_W { w : self , offset : 22 } } # [doc = "Set this bit to clear the rmt_ch(0-7)_err_int_raw."] # [inline (always)] pub unsafe fn ch_err_int_clr (& mut self , n : usize) -> CH_ERR_INT_CLR_W { CH_ERR_INT_CLR_W { w : self , offset : n * 3 + 2 } } # [doc = "Bit 2 - Set this bit to clear the rmt_ch0_err_int_raw."] # [inline (always)] pub fn ch0_err_int_clr (& mut self) -> CH_ERR_INT_CLR_W { CH_ERR_INT_CLR_W { w : self , offset : 2 } } # [doc = "Bit 5 - Set this bit to clear the rmt_ch1_err_int_raw."] # [inline (always)] pub fn ch1_err_int_clr (& mut self) -> CH_ERR_INT_CLR_W { CH_ERR_INT_CLR_W { w : self , offset : 5 } } # [doc = "Bit 8 - Set this bit to clear the rmt_ch2_err_int_raw."] # [inline (always)] pub fn ch2_err_int_clr (& mut self) -> CH_ERR_INT_CLR_W { CH_ERR_INT_CLR_W { w : self , offset : 8 } } # [doc = "Bit 11 - Set this bit to clear the rmt_ch3_err_int_raw."] # [inline (always)] pub fn ch3_err_int_clr (& mut self) -> CH_ERR_INT_CLR_W { CH_ERR_INT_CLR_W { w : self , offset : 11 } } # [doc = "Bit 14 - Set this bit to clear the rmt_ch4_err_int_raw."] # [inline (always)] pub fn ch4_err_int_clr (& mut self) -> CH_ERR_INT_CLR_W { CH_ERR_INT_CLR_W { w : self , offset : 14 } } # [doc = "Bit 17 - Set this bit to clear the rmt_ch5_err_int_raw."] # [inline (always)] pub fn ch5_err_int_clr (& mut self) -> CH_ERR_INT_CLR_W { CH_ERR_INT_CLR_W { w : self , offset : 17 } } # [doc = "Bit 20 - Set this bit to clear the rmt_ch6_err_int_raw."] # [inline (always)] pub fn ch6_err_int_clr (& mut self) -> CH_ERR_INT_CLR_W { CH_ERR_INT_CLR_W { w : self , offset : 20 } } # [doc = "Bit 23 - Set this bit to clear the rmt_ch7_err_int_raw."] # [inline (always)] pub fn ch7_err_int_clr (& mut self) -> CH_ERR_INT_CLR_W { CH_ERR_INT_CLR_W { w : self , offset : 23 } } # [doc = "Set this bit to clear the rmt_ch(0-7)_tx_thr_event_int_raw interrupt."] # [inline (always)] pub unsafe fn ch_tx_thr_event_int_clr (& mut self , n : usize) -> CH_TX_THR_EVENT_INT_CLR_W { CH_TX_THR_EVENT_INT_CLR_W { w : self , offset : n + 24 } } # [doc = "Bit 24 - Set this bit to clear the rmt_ch0_tx_thr_event_int_raw interrupt."] # [inline (always)] pub fn ch0_tx_thr_event_int_clr (& mut self) -> CH_TX_THR_EVENT_INT_CLR_W { CH_TX_THR_EVENT_INT_CLR_W { w : self , offset : 24 } } # [doc = "Bit 25 - Set this bit to clear the rmt_ch1_tx_thr_event_int_raw interrupt."] # [inline (always)] pub fn ch1_tx_thr_event_int_clr (& mut self) -> CH_TX_THR_EVENT_INT_CLR_W { CH_TX_THR_EVENT_INT_CLR_W { w : self , offset : 25 } } # [doc = "Bit 26 - Set this bit to clear the rmt_ch2_tx_thr_event_int_raw interrupt."] # [inline (always)] pub fn ch2_tx_thr_event_int_clr (& mut self) -> CH_TX_THR_EVENT_INT_CLR_W { CH_TX_THR_EVENT_INT_CLR_W { w : self , offset : 26 } } # [doc = "Bit 27 - Set this bit to clear the rmt_ch3_tx_thr_event_int_raw interrupt."] # [inline (always)] pub fn ch3_tx_thr_event_int_clr (& mut self) -> CH_TX_THR_EVENT_INT_CLR_W { CH_TX_THR_EVENT_INT_CLR_W { w : self , offset : 27 } } # [doc = "Bit 28 - Set this bit to clear the rmt_ch4_tx_thr_event_int_raw interrupt."] # [inline (always)] pub fn ch4_tx_thr_event_int_clr (& mut self) -> CH_TX_THR_EVENT_INT_CLR_W { CH_TX_THR_EVENT_INT_CLR_W { w : self , offset : 28 } } # [doc = "Bit 29 - Set this bit to clear the rmt_ch5_tx_thr_event_int_raw interrupt."] # [inline (always)] pub fn ch5_tx_thr_event_int_clr (& mut self) -> CH_TX_THR_EVENT_INT_CLR_W { CH_TX_THR_EVENT_INT_CLR_W { w : self , offset : 29 } } # [doc = "Bit 30 - Set this bit to clear the rmt_ch6_tx_thr_event_int_raw interrupt."] # [inline (always)] pub fn ch6_tx_thr_event_int_clr (& mut self) -> CH_TX_THR_EVENT_INT_CLR_W { CH_TX_THR_EVENT_INT_CLR_W { w : self , offset : 30 } } # [doc = "Bit 31 - Set this bit to clear the rmt_ch7_tx_thr_event_int_raw interrupt."] # [inline (always)] pub fn ch7_tx_thr_event_int_clr (& mut self) -> CH_TX_THR_EVENT_INT_CLR_W { CH_TX_THR_EVENT_INT_CLR_W { w : self , offset : 31 } } # [doc = "Writes raw bits to the register."] # [inline (always)] pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [int_clr](index.html) module"] pub struct INT_CLR_SPEC ; impl crate :: RegisterSpec for INT_CLR_SPEC { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [int_clr::W](W) writer structure"] impl crate :: Writable for INT_CLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INT_CLR to value 0"] impl crate :: Resettable for INT_CLR_SPEC { # [inline (always)] fn reset_value () -> Self :: Ux { 0 } } } } # [no_mangle] static mut DEVICE_PERIPHERALS : bool = false ; # [doc = r"All the peripherals"] # [allow (non_snake_case)] pub struct Peripherals { # [doc = "RMT"] pub RMT : RMT , } impl Peripherals { # [doc = r"Returns all the peripherals *once*"] # [inline] pub fn take () -> Option < Self > { xtensa_lx :: interrupt :: free (| _ | { if unsafe { DEVICE_PERIPHERALS } { None } else { Some (unsafe { Peripherals :: steal () }) } }) } # [doc = r"Unchecked version of `Peripherals::take`"] # [inline] pub unsafe fn steal () -> Self { DEVICE_PERIPHERALS = true ; Peripherals { RMT : RMT { _marker : PhantomData } , } } }